這個模式的核心目標非常明確：確保一個類別在應用程式中只會有一個實例 (instance)，並提供一個全域的存取點 (global point of access) 來取得該實例。這在很多情境下都至關重要，例如當你需要管理共用的資源時，像是執行緒池 (thread pools)、快取 (caches)、日誌物件 (logging objects)，或是印表機驅動程式等。如果這些物件被實例化超過一次，可能會導致程式行為不正確、資源過度使用或結果不一致。

以下是第五章「單例模式」(The Singleton Pattern) 的重點整理：

### 1. 單例模式的核心概念與目的

單例模式的宗旨在於，一個類別自行管理其唯一的實例，同時防止任何其他類別自行建立實例。要取得這個唯一的實例，必須透過該類別本身提供的方法。這麼做的好處是：
*   **確保唯一性**：保證應用程式中只有一個物件實例存在。
*   **提供全域存取點**：如同全域變數一樣方便存取，但避免了全域變數的一些缺點。
*   **支援延遲實例化 (Lazy Instantiation)**：物件可以在需要時才被建立，這對於資源密集型的物件特別重要，避免應用程式啟動時就建立一個可能從未被使用的昂貴物件。

### 2. 經典的單例模式實作方法

書中透過一個逐步引導的問答過程，揭示了經典的實作結構。其關鍵組成如下：
*   **私有建構子 (Private Constructor)**：將建構子宣告為 `private`，這是為了防止外部程式碼透過 `new` 關鍵字直接建立該類別的實例。只有該類別內部可以進行實例化。
*   **私有靜態變數 (Private Static Variable)**：在類別內部宣告一個 `private static` 的變數，用來持有那個唯一的實例。這個變數是屬於類別本身，而非物件。
*   **公開靜態存取方法 (`getInstance()`)**：提供一個 `public static` 的方法（通常命名為 `getInstance()`），作為外界取得唯一實例的統一窗口。這個方法的邏輯是：
    1.  檢查靜態變數是否為 `null`（即實例尚未建立）。
    2.  如果為 `null`，則在方法內部使用私有建構子建立一個新實例，並將其指派給靜態變數。
    3.  回傳該靜態變數所持有的實例。

### 3. 多執行緒環境下的挑戰與解決方案

經典的單例實作在單執行緒環境下運作良好，但在多執行緒環境下會出現問題。當兩個執行緒同時判斷 `uniqueInstance == null` 為真時，它們可能會各自建立一個實例，從而破壞了單例的唯一性。

書中提出了幾種解決方案來應對這個挑戰：

1.  **同步 `getInstance()` 方法 (Synchronized Method)**：
    *   **做法**：直接在 `getInstance()` 方法上加上 `synchronized` 關鍵字。
    *   **優點**：簡單有效，能確保執行緒安全 (thread-safe)。
    *   **缺點**：同步會帶來顯著的效能開銷，可能降低效能達 100 倍。而且，只有在第一次建立實例時才需要同步，後續的呼叫中，同步就變成了不必要的負擔。

2.  **立即實例化 (Eager Instantiation)**：
    *   **做法**：在宣告靜態變數時就直接建立實例，而不是等到 `getInstance()` 被呼叫時才建立。
    *   **優點**：利用 JVM 在載入類別時的機制來保證執行緒安全，且沒有同步的效能問題。
    *   **缺點**：失去了延遲實例化的好處。如果物件建立成本高昂，或者應用程式不一定會用到這個實例，就會造成資源浪費。

3.  **雙重檢查鎖定 (Double-Checked Locking)**：
    *   **做法**：首先檢查實例是否存在，如果不存在，才進入一個同步區塊。在同步區塊內再次檢查實例是否存在，若仍不存在，才建立實例。
    *   **優點**：在實例建立後，後續的呼叫不會進入同步區塊，大幅降低了效能開銷。
    *   **注意**：這個方法需要搭配 `volatile` 關鍵字來確保多執行緒環境下變數的可見性。同時，書中特別提醒，這個方法在 Java 1.4 及更早的版本中是無效的。

### 4. Java 中更現代且建議的實作方式：`enum`

書中最後提出了一個非常簡潔且強大的方法，就是使用 `enum`（列舉）來實作單例模式。
*   **做法**：宣告一個只有一個元素的 `enum`。
*   **優點**：這是目前在 Java 中實作單例模式最簡單且最安全的方式。它能自動處理多執行緒問題，並且還能防止透過反射 (reflection) 或序列化/反序列化 (serialization/deserialization) 破壞單例的唯一性。

### 5. 單例模式的潛在問題與考量

雖然單例模式很常用，但它也受到一些批評，使用時需要注意：
*   **多個類別載入器 (Class Loaders)**：在複雜的應用程式環境（如應用程式伺服器）中，如果有多個類別載入器，它們可能會各自載入一份單例類別，從而產生多個實例，破壞唯一性。
*   **違反單一職責原則 (Single Responsibility Principle)**：單例類別除了要負責其實際的業務邏輯外，還要負責管理自己的實例，這等於是承擔了兩種職責。
*   **緊密耦合 (Tight Coupling)**：依賴單例的物件會與這個具體的實例緊密耦合，這可能使得測試變得困難，也違反了「依賴抽象而非具體」的原則。
*   **子類別化困難**：因為單例的建構子是私有的，所以很難對其進行子類別化。

總結來說，第五章深入探討了如何正確且安全地實作單例模式，從經典方法到多執行緒環境下的各種解決方案，最後引導至使用 `enum` 的現代最佳實踐。它不僅是關於如何寫一個只有單一實例的類別，更是關於在真實世界複雜情境下的設計權衡。