# 狀態模式（State Pattern）

這是一個專門解決「物件行為隨內部狀態改變而改變」的優雅方案。

## 1. 初始問題：口香糖販賣機的模擬

開發初期，我們通常會使用傳統的狀態機設計方法。

* **做法：** 定義整數常數來代表不同的狀態，例如 `SOLD_OUT`（售罄）、`NO_QUARTER`（沒有 25 美分）、`HAS_QUARTER`（有 25 美分）、`SOLD`（售出商品）。
* **邏輯實現：** 在一個類別（如 `GumballMachine`）中，為每個動作（如 `insertQuarter`, `turnCrank`）撰寫大量的 `if-else` 或 `switch` 語句，根據當前狀態變數來決定行為與狀態跳轉。

## 2. 混亂的狀態：過度依賴條件判斷的代價

當需求變更（例如：新增一個「10% 抽中兩顆口香糖」的贏家狀態）時，這種設計會面臨災難。

* **維護困境：** 你必須在每一個方法中新增條件判斷邏輯來處理新狀態。
* **違反原則：** 這違反了「開閉原則」（Open-Closed Principle），且狀態跳轉邏輯被埋在條件陳述式中，不夠明確且容易產生 Bug。

## 3. 解決方案：重構為狀態模式

為了提高靈活性與維護性，我們將行為封裝進獨立的狀態類別中。

* **定義介面：** 定義一個 `State` 介面，其中包含所有可能的動作（如 `insertQuarter()`, `turnCrank()` 等）。
* **具體類別：** 為每個狀態實作一個類別（如 `NoQuarterState`, `HasQuarterState`），負責該狀態下的特定行為。
* **委派行為：** 販賣機（Context）不再自己處理行為，而是持有一個當前狀態對象的引用，並將請求委派（Delegate）給它。

## 4. 狀態模式的正式定義與結構

* **定義：** 狀態模式允許物件在內部狀態改變時改變其行為，物件看起來就像是改變了它的類別。
* **核心組件：**
  * **Context（上下文）：** 如 `GumballMachine`，負責維護當前狀態的實例，並定義外部感興趣的介面。
  * **State（介面）：** 定義封裝行為的共同介面。
  * **ConcreteState（具體狀態）：** 實作與 Context 的特定狀態相關的行為。

## 5. 狀態模式 vs. 策略模式 (Strategy Pattern)

兩者的類別圖幾乎完全相同，但**意圖（Intent）**截然不同：

* **狀態模式：** 被視為條件判斷式的替代方案。Context 會隨著時間在狀態對象集中自動切換，反映內部的變化，客戶端通常不直接干預。
* **策略模式：** 旨在提供可互換的演算法或行為。通常由客戶端主動指定 Context 要組合哪一個策略對象，且通常在整個生命週期中較少頻繁切換。

## 6. 進階範例：加入贏家狀態 (1 in 10 Game)

透過狀態模式，新增「贏家」邏輯變得非常簡單：

* **擴展性：** 只需新增一個 `WinnerState` 類別處理「發放兩顆口香糖」的邏輯。
* **狀態跳轉：** 在 `HasQuarterState` 的 `turnCrank()` 方法中加入隨機判斷，若中獎則跳轉至 `WinnerState`。這展示了模式如何將變動侷限在特定區塊，而不影響其他穩定的狀態。

## 7. 實務設計考量與權衡

身為工程師，在實作時需注意以下細節：

* **誰來管理切換：** 狀態跳轉可以由具體狀態類別負責（適合動態跳轉），也可以由 Context 負責（適合固定流程）。
* **類別數量：** 使用此模式會導致類別數量顯著增加，這是為了換取彈性所付出的代價。
* **共用狀態：** 如果多個 Context 需要共用狀態對象，可以將狀態實例設為靜態變數。
* **空實作處理：** 對於某些狀態下不合理的動作（如售罄時退幣），可以在 `State` 抽象類別中提供預設的錯誤提示訊息，以減少子類別重複代碼。

## 總結

狀態模式透過將「狀態」提升為一等公民（對象化），解決了大規模分支邏輯帶來的維護地獄。它讓系統對擴展開放（增加新狀態），對修改封閉（不改動現有邏輯），是開發高複雜度業務邏輯（如訂單系統、工作流引擎）時的必備工具。

## 狀態模式（State Pattern）與策略模式（Strategy Pattern）

身為一名資深演算法工程師，在設計複雜系統（如自動化交易平台或大型遊戲後端）時，經常會遇到這兩個結構極其相似的模式。雖然狀態模式（State Pattern）與策略模式（Strategy Pattern）在類別圖上幾乎完全相同，皆依賴於組合（Composition）與委派（Delegation），但它們的核心意圖與解決的問題場景有著本質上的區別。

### 1. 狀態模式（State Pattern）的主要意圖

狀態模式的核心意圖是讓一個物件在其內部狀態改變時，能夠自動改變其行為，使該物件看起來就像是「改變了所屬的類別」。

* **行為隨狀態演進：** 此模式的主要目標是將與特定狀態相關的行為封裝在獨立的狀態類別中。隨著時間的推移，上下文（Context）物件會在一組狀態物件中自動切換，以反映其內部狀態的變化，從而導致行為的改變。
* **消除複雜的分支邏輯：** 在演算法設計中，狀態模式被視為大規模條件判斷式（`if-else` 或 `switch`）的優雅替代方案。它將原本散落在各個方法中的狀態轉換邏輯轉移到狀態類別內部，使狀態轉移變得明確且易於擴展。
* **強調狀態轉移（State Transitions）：** 狀態模式建立在「離散狀態」與「定義明確的轉移流程」之上。在實作中，通常是由各個具體狀態類別來決定下一個狀態應該切換到哪裡，這是一個動態且自動的過程。

### 2. 策略模式（Strategy Pattern）的主要意圖

策略模式的核心意圖是定義一系列演算法，並將每一個演算法封裝起來，使它們可以相互替換，讓演算法的變化獨立於使用它的客戶端。

* **演算法的互換性：** 策略模式旨在提供一種靈活的機制來選擇「如何完成某件事」。例如，在鴨子模擬器中，不同的飛行行為（如火箭動力飛行或無法飛行）就是一組互相替換的策略。
* **替代繼承的彈性方案：** 策略模式的主要目標是作為子類別化（Subclassing）的替代方案。如果使用繼承來定義行為，行為會被靜態地固定在編譯時期；而透過策略模式，您可以透過組合在執行時期動態改變物件的行為。
* **由客戶端主動配置：** 與狀態模式不同，策略模式通常是由「客戶端」主動指定 Context 物件應該使用哪一個策略物件。在物件的生命週期中，雖然可以更換策略，但通常不會像狀態模式那樣頻繁且自動地進行切換。

### 3. 核心意圖的關鍵對比總結

從工程維護的角度來看，兩者的差異可以歸納為以下三點：

* **控制權的來源：** 在狀態模式中，狀態的切換通常是系統內部自動發生的， Context 物件會隨著業務邏輯的執行自動從一個狀態「流向」另一個狀態。而在策略模式中，通常是由外部使用者或配置來決定目前要採用哪一種「演算法」或「行為」。
* **對「變化」的解釋：** 狀態模式的意圖是處理物件內部性質的改變（如口香糖販賣機從「有錢」變成「售罄」），這會影響物件對所有動作的反應。策略模式則在於處理完成特定任務的不同手段（如不同的加密演算法或不同的排序方式），其關注點在於演算法的獨立性與互換性。
* **結構相似性下的不同目的：** 雖然兩者都將行為委派給另一個物件，但狀態模式的意圖是封裝「狀態相關的行為」，而策略模式的意圖是封裝「可替換的演算法」。

簡單來說，作為演算法工程師，當我需要物件根據目前的進度自動改變其對指令的反應時，我會選擇**狀態模式**；當我需要提供多種不同的方式來計算同一種結果，並讓呼叫者決定使用哪一種時，我會選擇**策略模式**。
