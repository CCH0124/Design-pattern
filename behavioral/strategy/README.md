## 策略模式 (Strategy Pattern)

### 1. 問題的開端：一個看似完美的 OO 設計

一開始，`SimUDuck` 遊戲的設計非常直觀，採用了標準的物件導向繼承架構。

*   **初始設計**：建立一個 `Duck` 抽象超類別（superclass），所有種類的鴨子（如 `MallardDuck`、`RedheadDuck`）都繼承自它。
*   **共享行為**：`quack()`（呱呱叫）和 `swim()`（游泳）等所有鴨子共通的行為，由 `Duck` 超類別提供具體實作。
*   **特有行為**：每種鴨子的外觀不同，所以 `display()` 方法被宣告為抽象方法，由各個子類別（subclass）各自實作。

這個設計在初期看起來相當不錯，充分利用了繼承來達到程式碼複用（code reuse）的目的。

### 2. 需求的變更與設計的崩壞

軟體開發中唯一不變的就是「**變更**」。當新的需求出現時，這個看似完美的設計開始出現裂痕。

*   **新需求**：高層要求為鴨子增加 `fly()`（飛行）的功能。
*   **直觀的錯誤作法**：開發者 Joe 很自然地在 `Duck` 超類別中加入了 `fly()` 方法，心想這樣所有的鴨子子類別就能立刻學會飛行。
*   **災難發生**：這個改動導致了非預期的副作用（non-local side effect）。像 `RubberDuck`（橡膠鴨）和 `DecoyDuck`（誘餌鴨）這些不應該會飛的「鴨子」也繼承了飛行能力，導致畫面上出現橡膠鴨滿天飛的荒謬場景。

這個問題暴露了單純依賴繼承來提供行為的嚴重缺點：
*   **僵化**：行為在編譯時期就靜態地綁定在子類別上，缺乏執行時期的彈性。
*   **不適當的行為**：子類別會繼承到所有行為，即使某些行為對它來說並不適合。
*   **維護困難**：當需求持續變更（例如未來要加入不會叫的木鴨），開發者將被迫不斷地在各個子類別中覆寫（override）不適用的方法，造成程式碼重複且難以維護。

### 3. 尋找更好的解決方案：設計原則的指引

為了解決上述困境，書中引導我們思考兩個替代方案，並從中提煉出關鍵的設計原則。

*   **方案一：使用介面 (Interface)**
    *   開發者 Joe 想到可以將 `fly()` 和 `quack()` 抽離成 `Flyable` 和 `Quackable` 介面，只讓會飛或會叫的鴨子去實作。
    *   **缺點**：這個作法雖然解決了行為不適當的問題，卻犧牲了程式碼複用。因為 Java 介面通常不帶有實作程式碼，這會導致飛行的實作邏輯在所有會飛的鴨子類別中被大量複製，創造出另一種維護惡夢。

在意識到繼承和介面都非完美解方後，書中提出了第一個核心設計原則：

> **設計原則一：找出應用程式中可能變動的部分，並將其與維持不變的部分分開 (Encapsulate what varies)。**

這個原則是幾乎所有設計模式的基礎。在 `SimUDuck` 案例中，飛行和呱呱叫的行為是變動的部分，而鴨子本身的基本屬性則相對穩定。因此，我們應該將這些行為從 `Duck` 類別中抽離出來，獨立封裝。

接著，書中介紹了第二個關鍵原則，指導我們如何設計這些被抽離出來的行為：

> **設計原則二：針對介面寫程式，而不是針對實作寫程式 (Program to an interface, not an implementation)。**

這意味著變數的宣告型別應該是超類型（supertype），例如抽象類別或介面，而不是具體的類別。這樣一來，程式碼就能與任何實作該介面的具體類別合作，利用多型（polymorphism）來增加彈性，避免被鎖死在特定的實作上。

### 4. 最終的解決方案：策略模式 (Strategy Pattern)

基於上述原則，最終的設計方案誕生了：

1.  **定義行為介面**：為飛行和呱呱叫分別建立 `FlyBehavior` 和 `QuackBehavior` 介面。
2.  **實作行為類別**：針對每種具體的飛行或呱呱叫方式，建立獨立的類別來實作對應的行為介面。例如，`FlyWithWings`、`FlyNoWay`、`Quack`、`Squeak` 等。
3.  **整合行為到 Duck 類別中**：
    *   在 `Duck` 類別中加入兩個型別為行為介面的實例變數（instance variables），例如 `flyBehavior` 和 `quackBehavior`。
    *   移除 `Duck` 類別中的 `fly()` 和 `quack()` 方法，改為 `performFly()` 和 `performQuack()` 方法。
    *   在這兩個新方法中，將行為**委派（delegate）**給行為物件去執行。例如，`performFly()` 會呼叫 `flyBehavior.fly()`。
4.  **動態設定行為**：
    *   在各個具體的鴨子類別（如 `MallardDuck`）的建構子（constructor）中，初始化其繼承來的行為變數，賦予它具體的行為物件。
    *   更進一步，可以在 `Duck` 類別中加入 setter 方法（如 `setFlyBehavior()`），讓鴨子的行為可以在**執行時期（runtime）動態地改變**。

這個設計體現了第三個重要的設計原則：

> **設計原則三：多用組合，少用繼承 (Favor composition over inheritance)。**

鴨子類別不再透過 **IS-A**（是一種）的繼承關係來獲得行為，而是透過 **HAS-A**（有一個）的組合（composition）關係，將行為物件組合進來。這種設計提供了極大的彈性，讓我們可以在執行時期改變行為，並且可以讓不同的物件（例如鴨子模型玩具）複用這些行為類別。

這個將一系列演算法（各種飛行和呱呱叫的方式）各自封裝，並讓它們可以互相替換的完整解決方案，就是**策略模式 (The Strategy Pattern)**。

> **策略模式定義**：定義一系列的演算法，並將每一個演算法封裝起來，讓它們可以互相替換。此模式讓演算法的改變獨立於使用演算法的客戶端。

### 5. 設計模式的價值：共享詞彙的力量

本章最後強調，設計模式不僅僅是技術解決方案，它更提供了一套**共享的詞彙（shared vocabulary）**。

當你和團隊成員說「這裡我們可以用策略模式」時，對方能立刻理解你指的是一個將演算法家族封裝起來、可動態替換、客戶端與具體實作解耦合的設計，而不需要從頭解釋整個複雜的結構。這種高效的溝通能讓團隊在設計層次上進行更深入的討論，而不是過早陷入實作細節。

總結來說，第一章透過 `SimUDuck` 的演化過程，闡述了從一個僵化的繼承設計，如何透過「封裝變動」、「針對介面編程」和「多用組合」等核心原則，重構成一個靈活、可維護的策略模式設計。這不僅解決了眼前的問題，更為軟體應對未來的**變更**打下了堅實的基礎。