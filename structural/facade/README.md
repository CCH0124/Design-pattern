# 外觀模式 (The Facade Pattern)

## 核心目的與定義

外觀模式（Facade Pattern）的目的是為子系統中的一組介面提供一個統一且簡化的介面。這使得客戶端不必處理子系統中各個元件的複雜性，從而使系統更容易使用。

* **定義**：外觀模式為子系統中的一組介面提供統一的介面。外觀模式定義了一個更高級別的介面，使子系統更容易使用。
* **意圖**：外觀模式的意圖是簡化介面和解耦客戶端與子系統，而不是像轉接器那樣進行介面轉換。
* **實作細節**：外觀類別（Facade）透過**組合**持有子系統內所有相關元件的引用。外觀類別的簡單方法（例如 `watchMovie()`）會將複雜的操作**委派**給子系統中的多個元件以完成任務。

## 設計原則的助益

外觀模式有助於遵循**最少知識原則**（Principle of Least Knowledge），因為客戶端只需與外觀（其「朋友」）互動，而無需知道如何調用子系統中的所有複雜元件。

* **存取控制**：外觀模式不會「封裝」子系統的類別；需要更進階功能的客戶端仍然可以直接存取子系統中的所有元件。

## 3. 最少知識原則 (The Principle of Least Knowledge)

最少知識原則（PLK）是指導物件導向設計的重要原則之一，旨在減少物件之間的耦合度，從而提高系統的穩健性（resilience to change）。

* **核心原則**：只和你的「親密朋友」交談（talk only to your immediate friends）。
* **目的**：避免設計出耦合度過高的系統，防止在系統某部分進行的變更（變更的連鎖反應，cascading change）擴散到其他不相關的部分。
* **合法的方法調用**：在任何物件的方法中，只應調用屬於以下類型的物件的方法：
  1. 物件本身的方法 (The object itself)。
  2. 作為參數傳入方法的物件 (Objects passed in as a parameter to the method)。
  3. 方法內部實例化或創建的物件 (Any object the method creates or instantiates)。
  4. 物件的任何元件（即實例變數）(Any components of the object)。
* **避免的行為**：該原則指導我們不要調用從其他方法調用返回的物件上的方法（例如：`station.getThermometer().getTemperature()`，這違反了原則）。為了遵循此原則，應讓擁有該元件的物件代為進行請求（例如：讓 `station` 物件提供一個 `getTemperature()` 方法，在內部調用其 `thermometer` 元件的方法）。

## 4. 總結設計考量

| 特性 | 轉接器模式 (Adapter Pattern) | 外觀模式 (Facade Pattern) |
| :--- | :--- | :--- |
| **主要意圖** | 轉換介面，使不相容的類別協同運作 | 簡化和統一介面，解耦客戶端和複雜子系統 |
| **實作方式** | 透過組合（Composition）包裹供應商物件，並實作目標介面 | 透過組合持有子系統元件，並將操作委派（Delegation）給子系統 |
| **結構關係** | 轉接器與目標介面相同，但與供應商介面不同 | 外觀介面通常與子系統介面不同，但其意圖是簡化而非轉換 |
| **設計原則**| 支援「多用組合少用繼承」（Favor Composition over Inheritance）。 | 支援「最少知識原則」（Principle of Least Knowledge）。 |
| **類別數量** | 增加類別和物件數量（轉接器和供應商）。 | 增加類別和物件數量（外觀和子系統元件）。 |