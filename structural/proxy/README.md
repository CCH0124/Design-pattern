# 代理模式（Proxy Pattern）
在建構分散式系統或優化資源密集型應用時，是我們用來控制物件存取、隱藏網路複雜性以及延遲加載資源的關鍵利器。


### 1. 代理模式的定義與核心意圖 (Definition and Intent)
代理模式為另一個物件提供一個**替身**或**佔位符**，以控制對該物件的存取。其核心目的在於「控制和管理存取」，讓客戶端不直接與真正的物件交談，而是透過一個中間層（代理）來處理。

### 2. 模式結構與角色 (Pattern Structure)
代理模式主要由以下三個角色構成：
*   **Subject (主題介面)**：定義了 `RealSubject` 和 `Proxy` 的共同介面。這使得客戶端可以將代理視為實體物件來處理。
*   **RealSubject (實體主題)**：真正執行業務邏輯或持有資源的物件。
*   **Proxy (代理)**：持有對 `RealSubject` 的引用。它負責攔截請求，並在必要時將請求轉發給 `RealSubject`。

### 3. 三大主要代理類型及其範例 (Key Types of Proxies)

#### A. 遠端代理 (Remote Proxy)
*   **功能**：充當遠端 JVM（Java 虛擬機）或不同位址空間中物件的本地代表。
*   **工程背景**：當物件位於不同的機器上時，代理會處理底層的網路通訊細節（如 Socket 連結、序列化等）。
*   **範例**：Gumball Machine 監控系統。透過 **RMI (Remote Method Invocation)**，CEO 的監控器（Client）可以在本地調用遠端機器上糖果機的 `getState()` 方法。
*   **關鍵機制**：RMI 使用 **Stub**（存根，即本地代理）和 **Skeleton**（骨架，服務端助手）來模擬本地調用的行為。

#### B. 虛擬代理 (Virtual Proxy)
*   **功能**：作為創建開銷極大的物件的代表。它會延遲（Defer）實體物件的創建，直到真正需要該物件為止。
*   **範例**：相簿封面查看器（Album Cover Viewer）。
    *   在圖片從網路下載完成前，`ImageProxy` 會在螢幕上顯示「正在加載中...」的訊息。
    *   一旦圖片下載完成（`ImageIcon` 被實例化），代理就會將後續所有的繪製請求轉發給真實的 `ImageIcon`。

#### C. 保護代理 (Protection Proxy)
*   **功能**：根據調用者的存取權限來控制對目標物件方法的存取。
*   **範例**：相親服務（Matchmaking Service）。
    *   **OwnerProxy**：允許用戶獲取和設置自己的個人資料，但禁止設置自己的「極客評分」（Geek Rating）。
    *   **NonOwnerProxy**：允許查看他人的資料，但禁止修改他人的個人資料，僅允許給他人評分。
*   **技術實作**：在 Java 中通常使用 **Dynamic Proxy**（動態代理）實作，透過 `java.lang.reflect.Proxy` 類別和 `InvocationHandler` 介面，在執行時期動態生成代理類別。

### 4. 進階代理變體 (The Proxy Zoo)
資料來源中還提到了一些其他的代理變體，這些在複雜系統架構中非常常見：
*   **快取代理 (Caching Proxy)**：暫存昂貴操作的結果，供多個客戶端共享，以減少運算開銷或網路延遲。
*   **防火牆代理 (Firewall Proxy)**：控制對網路資源的存取，保護主體不受「惡意」客戶端侵害。
*   **智能引用代理 (Smart Reference Proxy)**：在主體被引用時執行額外動作，例如計算物件的引用次數。
*   **同步代理 (Synchronization Proxy)**：在多執行緒環境中提供對主體的安全存取控制。
*   **寫入時複製代理 (Copy-On-Write Proxy)**：延遲物件的複製操作，直到客戶端真正需要修改物件為止（如 Java 的 `CopyOnWriteArrayList`）。

### 5. 與其他模式的對比 (Pattern Comparisons)
工程實務上，區分這些外觀相似的模式非常重要：
*   **與裝飾者模式 (Decorator) 的差異**：裝飾者的意圖是「增加行為」；而代理的意圖是「控制存取」。
*   **與轉接器模式 (Adapter) 的差異**：轉接器會改變物件的介面以求相容；代理則實作與目標相同的介面。

### 6. 資深工程師的實作筆記
1.  **RMI 限制**：遠端方法的所有參數和回傳值必須是原始型別或可序列化的（Serializable），因為它們必須經由序列化封裝後跨網路傳輸。
2.  **透明性與工廠**：為了讓客戶端感知不到代理的存在，通常會使用工廠（Factory）來實例化主體，並在回傳前用代理將其包裹起來。
3.  **動態代理**：Java 的 `newProxyInstance()` 方法需要傳入類別加載器（ClassLoader）、介面陣列以及 `InvocationHandler`。請注意，動態代理僅能針對「介面」生成，不能直接針對類別。