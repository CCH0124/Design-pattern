
#  組合模式 (Composite Pattern)

組合模式用於構建樹狀結構（tree structures），以表示對象的**整體—部分**（part-whole）層次結構，確保客戶端能以一致的方式處理獨立物件和物件的組合。

### 1. 問題動機與結構層次化

當集合中的元素本身可能也是包含其他元素（即子集合）的容器時，需要一種結構來管理這種遞歸關係。

*   在菜單系統的案例中，新的要求是支援子菜單（submenus）。一個菜單（Menu）既是一個集合，也是菜單項（MenuItem）的容器。

### 2. 模式定義與核心組件

組合模式的核心是確保客戶端對待單個對象（葉子）和對象的組合（組合節點）時，擁有統一的介面，從而實現操作的透明性。

*   **定義：** 組合模式允許將對象組合成樹狀結構，以表示整體—部分層次結構。它使得客戶端可以一致地處理單獨的對象和對象的組合。
*   **Component（元件）：** 定義了所有對象（包括葉子和組合節點）的通用介面，這可能是個抽象類。此介面通常包含**操作方法**（如 `print()`）和**子節點管理方法**（如 `add()`、`remove()`、`getChild()`）。
*   **Leaf（葉子）：** 代表結構中的單個對象（如 `MenuItem`），不包含子節點。葉子通常會繼承 `Component` 中的子節點管理方法，這些方法在葉子中沒有意義，預設應拋出 `UnsupportedOperationException`。
*   **Composite（組合）：** 代表包含子元件的對象（如 `Menu`），負責儲存和管理其子組件，並在操作方法中，遞歸地將請求轉發給其子元件。

### 3. 透明性與安全性權衡

在設計組合模式時，存在一個關鍵的權衡：

*   **透明性 (Transparency)：** 透過在 `Component` 介面中包含所有方法（包括子節點管理方法），客戶端可以無需區分正在處理的是葉子還是組合對象（即實現了操作的透明化）。
*   **安全性 (Safety)：** 缺點是，這種設計會讓客戶端可能在葉子節點上調用無意義的方法（如在 `MenuItem` 上調用 `add()`），這必須在運行時透過拋出異常來處理。

如果設計者選擇將子節點管理方法只放在 `Composite` 類中，則犧牲了透明性，但增強了類型安全，避免了在不適當的對象上調用方法。

### 4. 組合模式與迭代器模式的結合

在實現 `Composite` 類別的遍歷功能時（例如 `Flock` 類別在調用 `quack()` 時，需要遍歷所有 `Quackable` 子元素），`Iterator` 模式被自然地應用於 `Composite` 內部，以管理和遍歷其子組件集合。


## Composite 和 Iterator 模式差異

### 1. 設計意圖與核心定義的差異 (Difference in Intent and Definition)

*   **迭代器模式（Iterator Pattern）：**
    其核心目的在於提供一種方法，按順序存取一個聚合物件中的各個元素，而又不需暴露該物件的內部表示。它將遍歷（Traversal）的職責從集合物件中抽離，封裝到迭代器物件中。這讓開發者可以針對各種不同的底層資料結構（如 Array, ArrayList, HashMap）編寫多型（Polymorphic）的程式碼。
*   **組合模式（Composite Pattern）：**
    其目的是將物件組合成樹狀結構（Tree Structure），以表示「部分—整體（Part-whole）」的層次結構。組合模式讓客戶端（Client）能夠以一致的方式對待個別物件（葉子節點）和物件的組合（複合節點）。它解決了如何管理複雜遞歸結構（例如菜單中的子菜單）的問題。

### 2. 結構邏輯的差異 (Sequential vs. Recursive Structure)

*   **迭代器模式的線性思維：**
    迭代器專注於「線性的遍歷」。無論底層集合多麼複雜，迭代器提供給客戶端的都是簡約的介面（如 `hasNext()` 和 `next()`），讓客戶端可以像處理線性列表一樣處理資料。
*   **組合模式的遞歸思維：**
    組合模式建立了「樹狀層次」。它包含元件（Component）、葉子（Leaf）與組合（Composite）。組合節點內部會持有一個元件集合，這些元件可以是葉子，也可以是另一個組合節點，這種結構本質上是遞歸的。例如，一個菜單（Menu）中可以包含菜單項（MenuItem），也可以包含另一個菜單（Submenu）。

### 3. 設計原則與哲學的權衡 (SRP vs. Transparency)

這兩者在處理**單一職責原則（Single Responsibility Principle, SRP）**上有著截然不同的態度：

*   **迭代器模式堅守 SRP：**
    迭代器模式是單一職責原則的典範。它將「集合管理」與「遍歷管理」這兩個不同的職責分開。如果遍歷方式改變，只需修改迭代器；如果集合儲存方式改變，只需修改集合類別。
*   **組合模式為了「透明性」犧牲 SRP：**
    組合模式在設計上會讓元件介面同時包含「管理子節點」的操作（如 `add()`, `remove()`）和「葉子節點」的操作（如 `print()`）。這雖然違反了 SRP（一個類別承擔了多種職責），但卻換取了**透明性（Transparency）**。客戶端不需要判斷目前處理的是單一物件還是組合，可以直接統一呼叫方法，這極大地簡化了客戶端的邏輯。

### 4. 兩者的協作與互補 (Synergy and Cooperation)

這兩個模式並非互斥，而是經常「協作」：

*   **組合模式內部使用迭代器：**
    在實作組合模式的 `print()` 或其他操作方法時，組合節點通常會使用迭代器來遍歷其所有的子組件。例如，在「鴨子群（Flock）」的例子中，呼叫群體的 `quack()` 方法時，內部會使用迭代器遍歷群體中的每一隻鴨子並執行叫聲。
*   **多樣化遍歷：**
    雖然組合模式本身代表結構，但開發者可以為該組合結構實作不同的迭代器（如深度優先或廣度優先遍歷），這正是迭代器模式發揮作用之處。

### 總結差異表

| 特性 | 迭代器模式 (Iterator) | 組合模式 (Composite) |
| :--- | :--- | :--- |
| **主要目的** | 遍歷集合而不暴露其內部實作 | 建立部分—整體層次結構並實現一致性對待 |
| **結構類型** | 通常處理線性的序列 | 處理遞歸的樹狀結構 |
| **關注點** | 如何「存取」元素 | 如何「組織」物件 |
| **設計原則** | 嚴格遵循單一職責原則 (SRP) | 為了透明性而犧牲 SRP |
| **客戶端觀點** | 「給我下一個元素」 | 「你是一個組件，我對你執行操作」 |

簡而言之，**迭代器模式解決的是「如何走過這堆東西」的問題，而組合模式解決的是「這堆東西如何形成結構」以及「如何像處理一個東西一樣處理這堆東西」的問題。**